================================================================================
PULL REQUEST MESSAGE
================================================================================

Title: Code Cleanup and Bug Fixes - Improve Reliability and Code Quality

Description:

This PR improves code quality, adds comprehensive error handling, and fixes 
several critical bugs that could cause system instability. The changes focus 
on making the codebase more maintainable while preserving all existing 
functionality.

## Summary of Changes

### Code Organization & Structure
- Reorganized imports into logical groups (stdlib, third-party)
- Added comprehensive docstrings to all functions
- Improved code comments for better readability
- Refactored main execution flow into structured functions
- Better separation of concerns with helper functions

### Bug Fixes
- **Fixed resource leak**: Subprocess now properly terminates on shutdown
- **Fixed race condition**: Added thread-safe access to metadata list
- **Fixed index mismatch**: FAISS index and metadata now stay synchronized
- **Fixed invalid indices**: Added validation for FAISS search results
- **Fixed graceful shutdown**: Implemented proper shutdown event handling
- **Fixed error propagation**: Added try-catch blocks for critical operations

### Error Handling Improvements
- Model initialization now handles failures gracefully
- Subprocess errors are caught and logged
- Embedding failures no longer silently drop batches
- Search queries handle empty indices properly
- Invalid user input is validated with helpful messages
- Negative or zero k values are rejected

### Code Quality Improvements
- Added `shutdown_event` for coordinated thread termination
- Added `metadata_lock` to prevent concurrent access issues
- Improved query parsing with dedicated function
- Added model initialization function with error handling
- Better variable naming and code structure
- Improved user feedback messages

## Testing

All changes have been tested to ensure:
- Existing functionality is preserved
- System starts and stops cleanly
- No resource leaks during extended operation
- Thread-safe operations under concurrent load
- Proper error messages for invalid inputs

## Compatibility

- No breaking changes to user interface
- No changes to configuration options
- Maintains compatibility with existing log format
- Works with Python 3.9+

## Files Changed

- `db.py`: Complete refactoring with bug fixes and improvements

## Notes

- Code behavior remains identical for end users
- All logic improvements are internal
- Memory usage patterns unchanged
- Performance characteristics preserved


================================================================================
GITHUB ISSUES - BUG REPORTS
================================================================================

The following issues were identified in the codebase. These can be posted to 
the GitHub issues page. They have all been fixed in the associated PR.

--------------------------------------------------------------------------------
ISSUE #1: Resource Leak - journalctl Subprocess Never Terminates
--------------------------------------------------------------------------------

**Severity:** High
**Type:** Bug
**Component:** Log Streaming

**Description:**
The `watch_journalctl()` function spawns a subprocess for `journalctl -f` but 
never properly terminates it. When the program exits, the subprocess continues 
running in the background, consuming system resources.

**Steps to Reproduce:**
1. Start the system with `python3 db.py`
2. Exit the program using Ctrl+C or typing "exit"
3. Check running processes: `ps aux | grep journalctl`
4. Observe that journalctl process is still running

**Expected Behavior:**
All subprocess should terminate when the main program exits.

**Actual Behavior:**
The journalctl subprocess continues running indefinitely.

**Impact:**
- Memory leak over multiple runs
- Orphaned processes accumulate
- System resource waste

**Root Cause:**
No cleanup code in the thread function, and daemon threads don't handle 
subprocess termination.

**Fix:**
Added try-finally block with proper subprocess termination logic including 
SIGTERM followed by SIGKILL if needed.


--------------------------------------------------------------------------------
ISSUE #2: Race Condition in Metadata Access
--------------------------------------------------------------------------------

**Severity:** High
**Type:** Bug
**Component:** Thread Safety

**Description:**
The `metadata` list is accessed concurrently by multiple threads without 
synchronization:
- `embed_worker()` appends to it
- `search_query()` reads from it
This can cause data corruption or index out of bounds errors.

**Steps to Reproduce:**
1. Run system under high load (many simultaneous logs)
2. Perform searches while logs are being indexed
3. Occasionally see IndexError or incorrect search results

**Expected Behavior:**
Thread-safe access to shared data structures.

**Actual Behavior:**
Concurrent modification without locks leads to race conditions.

**Impact:**
- Crashes with IndexError
- Incorrect search results
- Data corruption

**Root Cause:**
Missing thread synchronization for shared mutable state.

**Fix:**
Added `metadata_lock` to protect all reads and writes to the metadata list.


--------------------------------------------------------------------------------
ISSUE #3: FAISS Index and Metadata Can Become Desynchronized
--------------------------------------------------------------------------------

**Severity:** Medium
**Type:** Bug
**Component:** Data Integrity

**Description:**
The FAISS index and metadata list are updated separately without atomic 
operations. If an error occurs between `index.add()` and metadata updates, 
they become out of sync, causing search to fail with index errors.

**Steps to Reproduce:**
1. Simulate failure in `model.encode()` (disconnect network during model load)
2. Observe that some vectors may be added but metadata is not
3. Search results reference incorrect metadata indices

**Expected Behavior:**
Index and metadata should always be synchronized.

**Actual Behavior:**
They can become mismatched, causing incorrect search results or crashes.

**Impact:**
- Search returns wrong log entries
- IndexError when accessing metadata
- Data integrity issues

**Root Cause:**
Non-atomic updates to related data structures without error recovery.

**Fix:**
Wrapped embedding and indexing in try-catch blocks and used thread locks to 
ensure atomic updates.


--------------------------------------------------------------------------------
ISSUE #4: Silent Failure on Embedding Errors
--------------------------------------------------------------------------------

**Severity:** Medium
**Type:** Bug
**Component:** Error Handling

**Description:**
If `model.encode()` fails (due to OOM, model corruption, etc.), the batch 
is silently dropped with no error message or logging. Users have no indication 
that data is being lost.

**Steps to Reproduce:**
1. Modify code to simulate encoding failure
2. Generate test logs
3. Observe that some logs never appear in search results
4. No error messages are displayed

**Expected Behavior:**
Errors should be logged and visible to users.

**Actual Behavior:**
Failures are silent and data is lost.

**Impact:**
- Data loss without user awareness
- Difficult to debug issues
- Silent corruption

**Root Cause:**
Missing exception handling in `embed_worker()`.

**Fix:**
Added try-catch blocks with error logging to stderr.


--------------------------------------------------------------------------------
ISSUE #5: No Validation for FAISS Invalid Indices
--------------------------------------------------------------------------------

**Severity:** Medium
**Type:** Bug
**Component:** Search

**Description:**
FAISS returns -1 for invalid indices when the index is empty or corrupted. 
The code attempts to access `metadata[idx]` without checking if `idx` is 
valid, causing IndexError.

**Steps to Reproduce:**
1. Start system and search immediately before any logs are indexed
2. May get IndexError or empty results
3. Edge case with corrupted index can also trigger this

**Expected Behavior:**
Invalid indices should be filtered out gracefully.

**Actual Behavior:**
Crashes with IndexError or returns incorrect results.

**Impact:**
- Program crashes on valid user input
- Poor user experience
- Unreliable search

**Root Cause:**
Missing validation for FAISS return values.

**Fix:**
Added check for `idx < 0` and `idx >= len(metadata)` before accessing.


--------------------------------------------------------------------------------
ISSUE #6: No Graceful Shutdown Mechanism
--------------------------------------------------------------------------------

**Severity:** Medium
**Type:** Bug
**Component:** Thread Management

**Description:**
The system uses daemon threads which are abruptly terminated when main thread 
exits. This prevents:
- Final batch of logs from being indexed
- Cleanup operations
- Proper subprocess termination

**Steps to Reproduce:**
1. Start system and generate logs
2. Exit immediately after log generation
3. Restart and search for recent logs
4. Some logs are missing

**Expected Behavior:**
All pending operations should complete before exit.

**Actual Behavior:**
Daemon threads are killed, losing in-progress work.

**Impact:**
- Data loss (unflushed batches)
- Incomplete indexing
- Orphaned resources

**Root Cause:**
No coordination mechanism for thread shutdown.

**Fix:**
Added `shutdown_event` for coordinated shutdown with final batch processing.


--------------------------------------------------------------------------------
ISSUE #7: Empty Index Causes Search to Crash
--------------------------------------------------------------------------------

**Severity:** Low
**Type:** Bug
**Component:** Search

**Description:**
Searching when the FAISS index is empty (no logs indexed yet) can cause 
unexpected behavior or crashes depending on FAISS version.

**Steps to Reproduce:**
1. Start fresh instance
2. Immediately search before flush interval
3. May see error or unexpected results

**Expected Behavior:**
Clear message indicating no logs are indexed yet.

**Actual Behavior:**
Error or confusing empty results.

**Impact:**
- Poor user experience
- Confusing error messages

**Root Cause:**
Missing check for `index.ntotal == 0`.

**Fix:**
Added check to return friendly message when index is empty.


--------------------------------------------------------------------------------
ISSUE #8: Model Initialization Errors Not Handled
--------------------------------------------------------------------------------

**Severity:** Medium
**Type:** Bug
**Component:** Initialization

**Description:**
If SentenceTransformer model fails to load (network issues, disk space, etc.), 
the program crashes with unhelpful error. Global `model` and `index` are 
initialized at module level, making error handling difficult.

**Steps to Reproduce:**
1. Disconnect network
2. Delete cached model files
3. Run `python3 db.py`
4. Observe crash with stack trace

**Expected Behavior:**
Clear error message explaining what went wrong and how to fix it.

**Actual Behavior:**
Cryptic stack trace from SentenceTransformer internals.

**Impact:**
- Poor first-run experience
- Users don't know how to resolve issues
- Difficult troubleshooting

**Root Cause:**
Model initialization happens at import time without error handling.

**Fix:**
Moved initialization to `initialize_models()` function with try-catch and 
helpful error messages.


--------------------------------------------------------------------------------
ISSUE #9: Invalid k Values Cause Incorrect Behavior
--------------------------------------------------------------------------------

**Severity:** Low
**Type:** Bug
**Component:** Input Validation

**Description:**
Users can specify `k=0` or `k=-5` which causes FAISS to behave unexpectedly.
Negative values may crash or return all results. Zero returns nothing.

**Steps to Reproduce:**
1. Run system
2. Search with `test k=0` or `test k=-10`
3. Observe unexpected behavior

**Expected Behavior:**
Invalid k values should be rejected with a warning.

**Actual Behavior:**
Accepted and causes incorrect search behavior.

**Impact:**
- Confusing user experience
- Potential crashes
- Incorrect results

**Root Cause:**
No validation for k parameter range.

**Fix:**
Added validation to reject k <= 0 with warning message.


--------------------------------------------------------------------------------
ISSUE #10: Search Can Request More Results Than Exist
--------------------------------------------------------------------------------

**Severity:** Low
**Type:** Bug
**Component:** Search

**Description:**
If user requests `k=1000` but only 50 logs are indexed, FAISS may return 
padding or behave unexpectedly depending on version.

**Steps to Reproduce:**
1. Index only a few logs
2. Search with very large k value
3. May get errors or unexpected results

**Expected Behavior:**
k should be automatically capped to available entries.

**Actual Behavior:**
FAISS searches for more results than exist.

**Impact:**
- Potential errors
- Confusing results
- Version-dependent behavior

**Root Cause:**
No check against `index.ntotal`.

**Fix:**
Added `k_adjusted = min(k, index.ntotal)` before search.


================================================================================
END OF DOCUMENT
================================================================================
